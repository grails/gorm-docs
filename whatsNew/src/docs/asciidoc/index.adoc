= What's New in GORM 6.1?
:author: Graeme Rocher
:email: graeme.rocher@gmail.com
:source-highlighter: coderay

== Introduction

GORM 6.1 builds on the concepts introduced in GORM 6 around Multi-Tenancy and includes a number of notable improvements.

TIP: To see all of the features introduced in GORM 6, see the http://gorm.grails.org/6.0.x/whatsNew/manual/[What's New guide for GORM 6.0].

The following sections cover the new features in GORM 6.1.

== New General Features

=== Multi-Tenancy Transformations

There are new transformations that can be applied to any class that simplify greatly the development of Multi-Tenant applications. These include:

- `@CurrentTenant` - Resolve the current tenant for the context of a class or method
- `@Tenant` - Use a specific tenant for the context of a class or method
- `@WithoutTenant` - Execute logic without a specific tenant (using the default connection)

For example:

[source,groovy]
----
import grails.gorm.multitenancy.*

// resolve the current tenant for every method
@CurrentTenant
class TeamService {

    // execute the countPlayers method without a tenant id
    @WithoutTenant
    int countPlayers() {
        Player.count()
    }

    // use the tenant id "another" for all GORM logic within the method
    @Tenant({"another"})
    List<Team> allTwoTeams() {
        Team.list()
    }

    List<Team> listTeams() {
        Team.list(max:10)
    }

    @Transactional
    void addTeam(String name) {
        new Team(name:name).save(flush:true)
    }
}
----

=== Support for Bean Validation API

If you prefer to use the standard http://beanvalidation.org[Bean Validation API] for validation, this is now possible with GORM. If you are using GORM for Hibernate simply add the necessary annotations to your entity:

[source,groovy]
----
import javax.validation.constraints.*

class Product {
    String name
    @Digits
    String price
}
----

If you are using another implementation you will need to add the `hibernate-validator` dependency to your `build.gradle`:

[source,groovy]
----
compile('org.hibernate:hibernate-validator:5.2.4.Final')
----

=== Support for Scanning Packages

The constructors for `HibernateDatastore`, `MongoDatastore` and `Neo4jDatastore` have been updated to support an array of `Package` instances representing the packages to scan for entities. This makes it easier to setup GORM outside of Grails or within unit tests. For example for Hibernate:

[source,groovy]
----
import org.grails.orm.hibernate.*

HibernateDatastore datastore = new HibernateDatastore(Package.getPackage("foo.bar"))
----

== New Hibernate Features

=== Hibernate 5.2 Support

Support for Hibernate 5.2 has been added (requires Java 8 minimum) and can be enabled by declaring an explicit dependency on Hibernate 5.2:

[source,groovy]
----
compile("org.hibernate:hibernate-core:5.2.0.Final")
----

=== JPA Mapping Support

Support for using JPA-annotated entites instead of GORM's DSL for entities written in Groovy has been added. For example:

[source,groovy]
----
import javax.persistence.*
import javax.validation.constraints.*

@Entity
class Product {
    @Id
    @GeneratedValue
    Long id
    String name

    @Digits(integer = 6, fraction = 2)
    String price
}
----

=== Automatic Escaping for HQL Queries

You can now pass Groovy's `GString` instances directly as HQL queries and these will be automatically escaped avoiding HQL-injection attacks:

[source,groovy]
----
String name = 'coffee'
Product p = Product.find("from Product as p where p.name = $name")
----

=== Support for Native SQL Queries

By implementing the `HibernateEntity` trait you can gain additional methods for using native SQL queries that feature the same automatic escaping for GString instances to avoid SQL-injection attacks:

[source,groovy]
----
import grails.gorm.hibernate.*

class Product implements HibernateEntity<Product> {
    ...
}

String name = 'coffee'
Product p = Product.findWithSql("select * from product p where p.name = $name")
----

=== Smart Hibernate Dirty Checking

GORM's `DirtyCheckable` AST transformations have been integrated with Hibernate's custom dirty checking API improving performance and increasing efficiency when doing large updates.

=== Hibernate Managed Entity Transform

An optional `@ManagedEntity` transformation has been added which can be applied to Hibernate entities which performs the same enhancements as Hibernate's https://docs.jboss.org/hibernate/orm/5.0/topical/html/bytecode/BytecodeEnhancement.html[Build time byte code enhancement] without the need for an additional Gradle plugin.

By applying `@ManagedEntity` to a class the class benefits from:

1. Lazy state initialization
2. Dirtiness tracking
3. Automatic bi-directional association management
4. Performance optimizations

This includes eliminating the need to generate proxies for the entity.

NOTE: There are some behavioural differences in lazy loading between `@ManagedEntity` enhanced entities and normal entities, hence why these enhancements are not applied by default and are opt-in.

== New MongoDB Features

=== Decimal128 Support

Support for MongoDB 3.4's new `Decimal128` type for representing `BigDecimal` values in Java has been added.

=== New findOneAndDelete Method

A new method to simplify using `findOneAndDelete` with native queries has been added:

[source,groovy]
----
import static com.mongodb.client.model.Filters.*

Product p = Product.findOneAndDelete(eq("title", "coffee"))
----

== New Neo4j Features

=== Relationship Entity Support

In addition to being able to map a domain class to a Neo4j `Node`, since 6.1 you are able to map a domain class to a Neo4j `Relationship`.

For example consider the following domain model:

[source,groovy]
----
import grails.neo4j.*

class Movie {
    String title
    static hasMany = [cast:CastMember]
}

class CastMember implements Relationship<Person, Movie> {
    List<String> roles = []
}

class Person {
    String name
    static hasMany = [appearances:CastMember]
}
----

The `CastMember` class implements the `Relationship` trait which takes two generic arguments: The class that represents the start of the relationship and the class that represents the end.

You can then use regular GORM methods to query the `CastMember` relationship. In addition because Neo4j relationships are dynamic you can assign additional properties to them at runtime. For example:

[source,groovy]
----
def castMember = new CastMember(
    from: new Person(name: "Keanu"),
    to: new Movie(title: "The Matrix"),
    roles: ["Neo"])

castMember['realName'] = "Thomas Anderson"
castMember.save(flush:true)
----

=== Relationship Mapping Support

More control over how relationships are mapped has been added via the `mapping` block. For example:

[source,groovy]
----
import static grails.neo4j.Direction.*

class Owner {
    String name
    static hasMany = [pets:Pet]

    static mapping = {
         pets type:"PETZ", direction:BOTH
    }
}
----

The `type` and `direction` settings can be used to specify the relationship type and direction.
